{"version":3,"sources":["webpack:/// [synthetic:util/objectcreate] ","webpack:/// [synthetic:es6/util/setprototypeof] ","webpack:/// [synthetic:es6/util/inherits] ","webpack:///bundle.js","webpack:///webpack/bootstrap 866aac55c2ec8414b6a5","webpack:///./~/preact-render-to-string/dist/index.js","webpack:///./~/preact/dist/preact.esm.js","webpack:///./test/entry.js"],"names":["$jscomp.objectCreate","$jscomp.setPrototypeOf","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","__webpack_require__.i","value","d","__webpack_require__.d","getter","o","Object","defineProperty","name","configurable","enumerable","get","n","__webpack_require__.n","__esModule","getDefault","getModuleExports","__webpack_require__.o","object","prototype","hasOwnProperty","p","s","global","factory","isLargeString","length","ignoreLines","String","indexOf","escapeChar","a","ESC","assign","obj","props","renderToString","vnode","context","opts","inner","isSvgMode","_ref","EMPTY","nodeName","attributes","children","isComponent","pretty","indentChar","replace","shallow","renderRootComponent","proto","Function","toString","str","component","match","index","UNNAMED","push","defaultProps","render","_disable","__x","componentWillMount","rendered","state","getChildContext","shallowHighOrder","html","attrs","objectKeys","sortAttributes","sort","v","allAttributes","toLowerCase","prop","val","jsToCss","NON_DIMENSION_PROPS","undefined","hooked","attributeHook","__html","xml","sub","VOID_ELEMENTS","len","pieces","hasLarge","_i","child","ret","childSvgMode","_i2","join","substring","jsx","boxFlex","boxFlexGroup","columnCount","fillOpacity","flex","flexGrow","flexPositive","flexShrink","flexNegative","fontWeight","lineClamp","lineHeight","opacity","order","orphans","strokeOpacity","widows","zIndex","zoom","keys","memoize","fn","mem","arguments","SHALLOW","shallowRender","__webpack_exports__","VNode","h","EMPTY_CHILDREN","simple","stack","pop","lastSimple","key","options","extend","enqueueRender","_dirty","items","debounceRendering","defer","rerender","list","renderComponent","getNodeProps","removeNode","node","parentNode","removeChild","setAccessor","old","isSvg","style","cssText","IS_NON_DIMENSIONAL","test","innerHTML","useCapture","addEventListener","eventProxy","removeEventListener","_listeners","e","removeAttribute","ns","removeAttributeNS","setAttributeNS","setAttribute","className","type","event","flushMounts","mounts","afterMount","componentDidMount","diff","dom","mountAll","parent","componentRoot","diffLevel","ownerSVGElement","hydrating","idiff","appendChild","out","prevSvgMode","splitText","_component","nodeValue","document","createTextNode","replaceChild","recollectNodeTree","vnodeName","originalComponent","oldDom","isDirectOwner","_componentConstructor","isOwner","_parentComponent","constructor","setComponentProps","base","unmountComponent","createComponent","nextBase","normalizedNodeName","createElementNS","createElement","firstChild","fc","vchildren","nextSibling","dangerouslySetInnerHTML","originalChildren","childNodes","keyed","keyedLen","min","childrenLen","vlen","_child","__key","isHydrating","trim","vchild","j","f","insertBefore","unmountOnly","ref","removeChildren","lastChild","next","previousSibling","Ctor","components","inst","Component","doRender","splice","__ref","componentWillReceiveProps","prevContext","prevProps","syncComponentUpdates","isChild","previousProps","previousState","prevState","previousContext","isUpdate","initialBase","initialChildComponent","skip","shouldComponentUpdate","componentWillUpdate","childComponent","childProps","toUnmount","cbase","baseParent","t","componentRef","unshift","componentDidUpdate","afterUpdate","_renderCallbacks","beforeUnmount","componentWillUnmount","Promise","resolve","then","bind","setTimeout","setState","callback","forceUpdate","preact","cloneElement","slice","merge","App","H1","__WEBPACK_IMPORTED_MODULE_0_preact__","__WEBPACK_IMPORTED_MODULE_1_preact_render_to_string__","__WEBPACK_IMPORTED_MODULE_1_preact_render_to_string___default","$jscomp.inherits","console","log"],"mappings":"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","file":"bundle.js","sourcesContent":["null\n\n\n// WEBPACK FOOTER //\n//  [synthetic:util/objectcreate] ","null\n\n\n// WEBPACK FOOTER //\n//  [synthetic:es6/util/setprototypeof] ","null\n\n\n// WEBPACK FOOTER //\n//  [synthetic:es6/util/inherits] ","/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.preactRenderToString = factory());\n}(this, (function () {\n\nvar NON_DIMENSION_PROPS = {\n\tboxFlex: 1, boxFlexGroup: 1, columnCount: 1, fillOpacity: 1, flex: 1, flexGrow: 1,\n\tflexPositive: 1, flexShrink: 1, flexNegative: 1, fontWeight: 1, lineClamp: 1, lineHeight: 1,\n\topacity: 1, order: 1, orphans: 1, strokeOpacity: 1, widows: 1, zIndex: 1, zoom: 1\n};\n\nvar ESC = {\n\t'<': '&lt;',\n\t'>': '&gt;',\n\t'\"': '&quot;',\n\t'&': '&amp;'\n};\n\nvar objectKeys = Object.keys || function (obj) {\n\tvar keys = [];\n\tfor (var i in obj) {\n\t\tif (obj.hasOwnProperty(i)) keys.push(i);\n\t}return keys;\n};\n\nvar encodeEntities = function (s) {\n\treturn String(s).replace(/[<>\"&]/g, escapeChar);\n};\n\nvar escapeChar = function (a) {\n\treturn ESC[a] || a;\n};\n\nvar falsey = function (v) {\n\treturn v == null || v === false;\n};\n\nvar memoize = function (fn) {\n\tvar mem = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\treturn function (v) {\n\t\treturn mem[v] || (mem[v] = fn(v));\n\t};\n};\n\nvar indent = function (s, char) {\n\treturn String(s).replace(/(\\n+)/g, '$1' + (char || '\\t'));\n};\n\nvar isLargeString = function (s, length, ignoreLines) {\n\treturn String(s).length > (length || 40) || !ignoreLines && String(s).indexOf('\\n') !== -1 || String(s).indexOf('<') !== -1;\n};\n\nfunction styleObjToCss(s) {\n\tvar str = '';\n\tfor (var prop in s) {\n\t\tvar val = s[prop];\n\t\tif (val != null) {\n\t\t\tif (str) str += ' ';\n\t\t\tstr += jsToCss(prop);\n\t\t\tstr += ': ';\n\t\t\tstr += val;\n\t\t\tif (typeof val === 'number' && !NON_DIMENSION_PROPS[prop]) {\n\t\t\t\tstr += 'px';\n\t\t\t}\n\t\t\tstr += ';';\n\t\t}\n\t}\n\treturn str || undefined;\n}\n\nfunction hashToClassName(c) {\n\tvar str = '';\n\tfor (var prop in c) {\n\t\tif (c[prop]) {\n\t\t\tif (str) str += ' ';\n\t\t\tstr += prop;\n\t\t}\n\t}\n\treturn str;\n}\n\nvar jsToCss = memoize(function (s) {\n\treturn s.replace(/([A-Z])/g, '-$1').toLowerCase();\n});\n\nfunction assign(obj, props) {\n\tfor (var i in props) {\n\t\tobj[i] = props[i];\n\t}return obj;\n}\n\nfunction getNodeProps(vnode) {\n\tvar defaultProps = vnode.nodeName.defaultProps,\n\t    props = assign({}, defaultProps || vnode.attributes);\n\tif (defaultProps) assign(props, vnode.attributes);\n\tif (vnode.children) props.children = vnode.children;\n\treturn props;\n}\n\nvar SHALLOW = { shallow: true };\n\nvar UNNAMED = [];\n\nvar EMPTY = {};\n\nvar VOID_ELEMENTS = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\nrenderToString.render = renderToString;\n\nvar shallowRender = function (vnode, context) {\n\treturn renderToString(vnode, context, SHALLOW);\n};\n\nfunction renderToString(vnode, context, opts, inner, isSvgMode) {\n\tvar _ref = vnode || EMPTY;\n\n\tvar nodeName = _ref.nodeName;\n\tvar attributes = _ref.attributes;\n\tvar children = _ref.children;\n\tvar isComponent = false;\n\tcontext = context || {};\n\topts = opts || {};\n\n\tvar pretty = opts.pretty,\n\t    indentChar = typeof pretty === 'string' ? pretty : '\\t';\n\n\tif (vnode == null || vnode === false) {\n\t\treturn '';\n\t}\n\n\tif (!nodeName) {\n\t\treturn encodeEntities(vnode);\n\t}\n\n\tif (typeof nodeName === 'function') {\n\t\tisComponent = true;\n\t\tif (opts.shallow && (inner || opts.renderRootComponent === false)) {\n\t\t\tnodeName = getComponentName(nodeName);\n\t\t} else {\n\t\t\tvar props = getNodeProps(vnode),\n\t\t\t    rendered = void 0;\n\n\t\t\tif (!nodeName.prototype || typeof nodeName.prototype.render !== 'function') {\n\t\t\t\trendered = nodeName(props, context);\n\t\t\t} else {\n\t\t\t\tvar c = new nodeName(props, context);\n\n\t\t\t\tc._disable = c.__x = true;\n\t\t\t\tc.props = props;\n\t\t\t\tc.context = context;\n\t\t\t\tif (c.componentWillMount) c.componentWillMount();\n\t\t\t\trendered = c.render(c.props, c.state, c.context);\n\n\t\t\t\tif (c.getChildContext) {\n\t\t\t\t\tcontext = assign(assign({}, context), c.getChildContext());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn renderToString(rendered, context, opts, opts.shallowHighOrder !== false);\n\t\t}\n\t}\n\n\tvar s = '',\n\t    html = void 0;\n\n\tif (attributes) {\n\t\tvar attrs = objectKeys(attributes);\n\n\t\tif (opts && opts.sortAttributes === true) attrs.sort();\n\n\t\tfor (var i = 0; i < attrs.length; i++) {\n\t\t\tvar name = attrs[i],\n\t\t\t    v = attributes[name];\n\t\t\tif (name === 'children') continue;\n\t\t\tif (!(opts && opts.allAttributes) && (name === 'key' || name === 'ref')) continue;\n\n\t\t\tif (name === 'className') {\n\t\t\t\tif (attributes['class']) continue;\n\t\t\t\tname = 'class';\n\t\t\t} else if (isSvgMode && name.match(/^xlink\\:?(.+)/)) {\n\t\t\t\tname = name.toLowerCase().replace(/^xlink\\:?(.+)/, 'xlink:$1');\n\t\t\t}\n\n\t\t\tif (name === 'class' && v && typeof v === 'object') {\n\t\t\t\tv = hashToClassName(v);\n\t\t\t} else if (name === 'style' && v && typeof v === 'object') {\n\t\t\t\tv = styleObjToCss(v);\n\t\t\t}\n\n\t\t\tvar hooked = opts.attributeHook && opts.attributeHook(name, v, context, opts, isComponent);\n\t\t\tif (hooked || hooked === '') {\n\t\t\t\ts += hooked;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (name === 'dangerouslySetInnerHTML') {\n\t\t\t\thtml = v && v.__html;\n\t\t\t} else if ((v || v === 0 || v === '') && typeof v !== 'function') {\n\t\t\t\tif (v === true || v === '') {\n\t\t\t\t\tv = name;\n\n\t\t\t\t\tif (!opts || !opts.xml) {\n\t\t\t\t\t\ts += ' ' + name;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts += ' ' + name + '=\"' + encodeEntities(v) + '\"';\n\t\t\t}\n\t\t}\n\t}\n\n\tvar sub = s.replace(/^\\n\\s*/, ' ');\n\tif (sub !== s && !~sub.indexOf('\\n')) s = sub;else if (pretty && ~s.indexOf('\\n')) s += '\\n';\n\n\ts = '<' + nodeName + s + '>';\n\n\tif (VOID_ELEMENTS.indexOf(nodeName) > -1) {\n\t\ts = s.replace(/>$/, ' />');\n\t}\n\n\tif (html) {\n\t\tif (pretty && isLargeString(html)) {\n\t\t\thtml = '\\n' + indentChar + indent(html, indentChar);\n\t\t}\n\t\ts += html;\n\t} else {\n\t\tvar len = children && children.length,\n\t\t    pieces = [],\n\t\t    hasLarge = ~s.indexOf('\\n');\n\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\tvar child = children[_i];\n\t\t\tif (!falsey(child)) {\n\t\t\t\tvar childSvgMode = nodeName === 'svg' ? true : nodeName === 'foreignObject' ? false : isSvgMode,\n\t\t\t\t    ret = renderToString(child, context, opts, true, childSvgMode);\n\t\t\t\tif (!hasLarge && pretty && isLargeString(ret)) hasLarge = true;\n\t\t\t\tif (ret) pieces.push(ret);\n\t\t\t}\n\t\t}\n\t\tif (pretty && hasLarge) {\n\t\t\tfor (var _i2 = pieces.length; _i2--;) {\n\t\t\t\tpieces[_i2] = '\\n' + indentChar + indent(pieces[_i2], indentChar);\n\t\t\t}\n\t\t}\n\t\tif (pieces.length) {\n\t\t\ts += pieces.join('');\n\t\t} else if (opts && opts.xml) {\n\t\t\treturn s.substring(0, s.length - 1) + ' />';\n\t\t}\n\t}\n\n\tif (opts.jsx || VOID_ELEMENTS.indexOf(nodeName) === -1) {\n\t\tif (pretty && ~s.indexOf('\\n')) s += '\\n';\n\t\ts += '</' + nodeName + '>';\n\t}\n\n\treturn s;\n}\n\nfunction getComponentName(component) {\n\tvar proto = component.prototype,\n\t    ctor = proto && proto.constructor;\n\treturn component.displayName || component.name || proto && (proto.displayName || proto.name) || getFallbackComponentName(component);\n}\n\nfunction getFallbackComponentName(component) {\n\tvar str = Function.prototype.toString.call(component),\n\t    name = (str.match(/^\\s*function\\s+([^\\( ]+)/) || EMPTY)[1];\n\tif (!name) {\n\t\tvar index = -1;\n\t\tfor (var i = UNNAMED.length; i--;) {\n\t\t\tif (UNNAMED[i] === component) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (index < 0) {\n\t\t\tindex = UNNAMED.push(component) - 1;\n\t\t}\n\t\tname = 'UnnamedComponent' + index;\n\t}\n\treturn name;\n}\nrenderToString.shallowRender = shallowRender;\n\nreturn renderToString;\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export h */\n/* unused harmony export createElement */\n/* unused harmony export cloneElement */\n/* unused harmony export Component */\n/* unused harmony export render */\n/* unused harmony export rerender */\n/* unused harmony export options */\n/** Virtual DOM Node */\nfunction VNode() {}\n\n/** Global options\n *\t@public\n *\t@namespace options {Object}\n */\nvar options = {\n\n\t/** If `true`, `prop` changes trigger synchronous component updates.\n  *\t@name syncComponentUpdates\n  *\t@type Boolean\n  *\t@default true\n  */\n\t//syncComponentUpdates: true,\n\n\t/** Processes all created VNodes.\n  *\t@param {VNode} vnode\tA newly-created VNode to normalize/process\n  */\n\t//vnode(vnode) { }\n\n\t/** Hook invoked after a component is mounted. */\n\t// afterMount(component) { }\n\n\t/** Hook invoked after the DOM is updated with a component's latest render. */\n\t// afterUpdate(component) { }\n\n\t/** Hook invoked immediately before a component is unmounted. */\n\t// beforeUnmount(component) { }\n};\n\nvar stack = [];\n\nvar EMPTY_CHILDREN = [];\n\n/** JSX/hyperscript reviver\n*\tBenchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0\n *\t@see http://jasonformat.com/wtf-is-jsx\n *\t@public\n */\nfunction h(nodeName, attributes) {\n\tvar children = EMPTY_CHILDREN,\n\t    lastSimple,\n\t    child,\n\t    simple,\n\t    i;\n\tfor (i = arguments.length; i-- > 2;) {\n\t\tstack.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children != null) {\n\t\tif (!stack.length) stack.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack.length) {\n\t\tif ((child = stack.pop()) && child.pop !== undefined) {\n\t\t\tfor (i = child.length; i--;) {\n\t\t\t\tstack.push(child[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof child === 'boolean') child = null;\n\n\t\t\tif (simple = typeof nodeName !== 'function') {\n\t\t\t\tif (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length - 1] += child;\n\t\t\t} else if (children === EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t} else {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tvar p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes == null ? undefined : attributes;\n\tp.key = attributes == null ? undefined : attributes.key;\n\n\t// if a \"vnode hook\" is defined, pass every created VNode to it\n\tif (options.vnode !== undefined) options.vnode(p);\n\n\treturn p;\n}\n\n/** Copy own-properties from `props` onto `obj`.\n *\t@returns obj\n *\t@private\n */\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }return obj;\n}\n\n/** Call a function asynchronously, as soon as possible.\n *\t@param {Function} callback\n */\nvar defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n\nfunction cloneElement(vnode, props) {\n\treturn h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n}\n\n// DOM properties that should NOT have \"px\" added when numeric\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\n/** Managed queue of dirty components to be re-rendered */\n\nvar items = [];\n\nfunction enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component) == 1) {\n\t\t(options.debounceRendering || defer)(rerender);\n\t}\n}\n\nfunction rerender() {\n\tvar p,\n\t    list = items;\n\titems = [];\n\twhile (p = list.pop()) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n\n/** Check if two nodes are equivalent.\n *\t@param {Element} node\n *\t@param {VNode} vnode\n *\t@private\n */\nfunction isSameNodeType(node, vnode, hydrating) {\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\treturn node.splitText !== undefined;\n\t}\n\tif (typeof vnode.nodeName === 'string') {\n\t\treturn !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n\t}\n\treturn hydrating || node._componentConstructor === vnode.nodeName;\n}\n\n/** Check if an Element has a given normalized name.\n*\t@param {Element} node\n*\t@param {String} nodeName\n */\nfunction isNamedNode(node, nodeName) {\n\treturn node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n}\n\n/**\n * Reconstruct Component-style `props` from a VNode.\n * Ensures default/fallback values from `defaultProps`:\n * Own-properties of `defaultProps` not present in `vnode.attributes` are added.\n * @param {VNode} vnode\n * @returns {Object} props\n */\nfunction getNodeProps(vnode) {\n\tvar props = extend({}, vnode.attributes);\n\tprops.children = vnode.children;\n\n\tvar defaultProps = vnode.nodeName.defaultProps;\n\tif (defaultProps !== undefined) {\n\t\tfor (var i in defaultProps) {\n\t\t\tif (props[i] === undefined) {\n\t\t\t\tprops[i] = defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn props;\n}\n\n/** Create an element with the given nodeName.\n *\t@param {String} nodeName\n *\t@param {Boolean} [isSvg=false]\tIf `true`, creates an element within the SVG namespace.\n *\t@returns {Element} node\n */\nfunction createNode(nodeName, isSvg) {\n\tvar node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\n/** Remove a child node from its parent if attached.\n *\t@param {Element} node\t\tThe node to remove\n */\nfunction removeNode(node) {\n\tvar parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\n/** Set a named attribute on the given Node, with special behavior for some names and event handlers.\n *\tIf `value` is `null`, the attribute/handler will be removed.\n *\t@param {Element} node\tAn element to mutate\n *\t@param {string} name\tThe name/key to set, such as an event or attribute name\n *\t@param {any} old\tThe last value that was set for this name/node pair\n *\t@param {any} value\tAn attribute value, such as a function to be used as an event handler\n *\t@param {Boolean} isSvg\tAre we currently diffing inside an svg?\n *\t@private\n */\nfunction setAccessor(node, name, old, value, isSvg) {\n\tif (name === 'className') name = 'class';\n\n\tif (name === 'key') {\n\t\t// ignore\n\t} else if (name === 'ref') {\n\t\tif (old) old(null);\n\t\tif (value) value(node);\n\t} else if (name === 'class' && !isSvg) {\n\t\tnode.className = value || '';\n\t} else if (name === 'style') {\n\t\tif (!value || typeof value === 'string' || typeof old === 'string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value === 'object') {\n\t\t\tif (typeof old !== 'string') {\n\t\t\t\tfor (var i in old) {\n\t\t\t\t\tif (!(i in value)) node.style[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in value) {\n\t\t\t\tnode.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];\n\t\t\t}\n\t\t}\n\t} else if (name === 'dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t} else if (name[0] == 'o' && name[1] == 'n') {\n\t\tvar useCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {\n\t\tsetProperty(node, name, value == null ? '' : value);\n\t\tif (value == null || value === false) node.removeAttribute(name);\n\t} else {\n\t\tvar ns = isSvg && name !== (name = name.replace(/^xlink\\:?/, ''));\n\t\tif (value == null || value === false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/** Attempt to set a DOM property to the given value.\n *\tIE & FF throw for certain property-value combinations.\n */\nfunction setProperty(node, name, value) {\n\ttry {\n\t\tnode[name] = value;\n\t} catch (e) {}\n}\n\n/** Proxy an event to hooked event handlers\n *\t@private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event && options.event(e) || e);\n}\n\n/** Queue of components that have been mounted and are awaiting componentDidMount */\nvar mounts = [];\n\n/** Diff recursion count, used to track the end of the diff cycle. */\nvar diffLevel = 0;\n\n/** Global flag indicating if the diff is currently within an SVG */\nvar isSvgMode = false;\n\n/** Global flag indicating if the diff is performing hydration */\nvar hydrating = false;\n\n/** Invoke queued componentDidMount lifecycle methods */\nfunction flushMounts() {\n\tvar c;\n\twhile (c = mounts.pop()) {\n\t\tif (options.afterMount) options.afterMount(c);\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\n/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.\n *\t@param {Element} [dom=null]\t\tA DOM node to mutate into the shape of the `vnode`\n *\t@param {VNode} vnode\t\t\tA VNode (with descendants forming a tree) representing the desired DOM structure\n *\t@returns {Element} dom\t\t\tThe created/mutated element\n *\t@private\n */\nfunction diff(dom, vnode, context, mountAll, parent, componentRoot) {\n\t// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)\n\tif (!diffLevel++) {\n\t\t// when first starting the diff, check if we're diffing an SVG or within an SVG\n\t\tisSvgMode = parent != null && parent.ownerSVGElement !== undefined;\n\n\t\t// hydration is indicated by the existing element to be diffed not having a prop cache\n\t\thydrating = dom != null && !('__preactattr_' in dom);\n\t}\n\n\tvar ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\t// append the element if its a new parent\n\tif (parent && ret.parentNode !== parent) parent.appendChild(ret);\n\n\t// diffLevel being reduced to 0 means we're exiting the diff\n\tif (! --diffLevel) {\n\t\thydrating = false;\n\t\t// invoke queued componentDidMount lifecycle methods\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\n/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tvar out = dom,\n\t    prevSvgMode = isSvgMode;\n\n\t// empty values (null, undefined, booleans) render as empty Text nodes\n\tif (vnode == null || typeof vnode === 'boolean') vnode = '';\n\n\t// Fast case: Strings & Numbers create/update Text nodes.\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\n\t\t// update if it's already a Text node:\n\t\tif (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\t/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */\n\t\t\tif (dom.nodeValue != vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t} else {\n\t\t\t// it wasn't a Text node: replace it with one and recycle the old Element\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout['__preactattr_'] = true;\n\n\t\treturn out;\n\t}\n\n\t// If the VNode represents a Component, perform a component diff:\n\tvar vnodeName = vnode.nodeName;\n\tif (typeof vnodeName === 'function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;\n\n\t// If there's no existing element or it's the wrong type, create a new one:\n\tvnodeName = String(vnodeName);\n\tif (!dom || !isNamedNode(dom, vnodeName)) {\n\t\tout = createNode(vnodeName, isSvgMode);\n\n\t\tif (dom) {\n\t\t\t// move children into the replacement node\n\t\t\twhile (dom.firstChild) {\n\t\t\t\tout.appendChild(dom.firstChild);\n\t\t\t} // if the previous Element was mounted into the DOM, replace it inline\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\t// recycle the old element (skips non-Element node types)\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\tvar fc = out.firstChild,\n\t    props = out['__preactattr_'],\n\t    vchildren = vnode.children;\n\n\tif (props == null) {\n\t\tprops = out['__preactattr_'] = {};\n\t\tfor (var a = out.attributes, i = a.length; i--;) {\n\t\t\tprops[a[i].name] = a[i].value;\n\t\t}\n\t}\n\n\t// Optimization: fast-path for elements containing a single TextNode:\n\tif (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {\n\t\tif (fc.nodeValue != vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t}\n\t// otherwise, if there are existing or new children, diff them:\n\telse if (vchildren && vchildren.length || fc != null) {\n\t\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);\n\t\t}\n\n\t// Apply attributes/props from VNode to the DOM Element:\n\tdiffAttributes(out, vnode.attributes, props);\n\n\t// restore previous SVG mode: (in case we're exiting an SVG namespace)\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\n/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.\n *\t@param {Element} dom\t\t\tElement whose children should be compared & mutated\n *\t@param {Array} vchildren\t\tArray of VNodes to compare to `dom.childNodes`\n *\t@param {Object} context\t\t\tImplicitly descendant context object (from most recent `getChildContext()`)\n *\t@param {Boolean} mountAll\n *\t@param {Boolean} isHydrating\tIf `true`, consumes externally created elements similar to hydration\n */\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tvar originalChildren = dom.childNodes,\n\t    children = [],\n\t    keyed = {},\n\t    keyedLen = 0,\n\t    min = 0,\n\t    len = originalChildren.length,\n\t    childrenLen = 0,\n\t    vlen = vchildren ? vchildren.length : 0,\n\t    j,\n\t    c,\n\t    f,\n\t    vchild,\n\t    child;\n\n\t// Build up a map of keyed children and an Array of unkeyed children:\n\tif (len !== 0) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar _child = originalChildren[i],\n\t\t\t    props = _child['__preactattr_'],\n\t\t\t    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;\n\t\t\tif (key != null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = _child;\n\t\t\t} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = _child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen !== 0) {\n\t\tfor (var i = 0; i < vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\t// attempt to find a node based on key matching\n\t\t\tvar key = vchild.key;\n\t\t\tif (key != null) {\n\t\t\t\tif (keyedLen && keyed[key] !== undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// attempt to pluck a node of the same type from the existing children\n\t\t\telse if (!child && min < childrenLen) {\n\t\t\t\t\tfor (j = min; j < childrenLen; j++) {\n\t\t\t\t\t\tif (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\t\tif (j === childrenLen - 1) childrenLen--;\n\t\t\t\t\t\t\tif (j === min) min++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// morph the matched/found/created DOM child to match vchild (deep)\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tf = originalChildren[i];\n\t\t\tif (child && child !== dom && child !== f) {\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t} else if (child === f.nextSibling) {\n\t\t\t\t\tremoveNode(f);\n\t\t\t\t} else {\n\t\t\t\t\tdom.insertBefore(child, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// remove unused keyed children:\n\tif (keyedLen) {\n\t\tfor (var i in keyed) {\n\t\t\tif (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);\n\t\t}\n\t}\n\n\t// remove orphaned unkeyed children:\n\twhile (min <= childrenLen) {\n\t\tif ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);\n\t}\n}\n\n/** Recursively recycle (or just unmount) a node and its descendants.\n *\t@param {Node} node\t\t\t\t\t\tDOM node to start unmount/removal from\n *\t@param {Boolean} [unmountOnly=false]\tIf `true`, only triggers unmount lifecycle, skips removal\n */\nfunction recollectNodeTree(node, unmountOnly) {\n\tvar component = node._component;\n\tif (component) {\n\t\t// if node is owned by a Component, unmount that component (ends up recursing back here)\n\t\tunmountComponent(component);\n\t} else {\n\t\t// If the node's VNode had a ref function, invoke it with null here.\n\t\t// (this is part of the React spec, and smart for unsetting references)\n\t\tif (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);\n\n\t\tif (unmountOnly === false || node['__preactattr_'] == null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\n/** Recollect/unmount all children.\n *\t- we use .lastChild here because it causes less reflow than .firstChild\n *\t- it's also cheaper than accessing the .childNodes Live NodeList\n */\nfunction removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tvar next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\n/** Apply differences in attributes from a VNode to the given DOM Element.\n *\t@param {Element} dom\t\tElement with attributes to diff `attrs` against\n *\t@param {Object} attrs\t\tThe desired end-state key-value attribute pairs\n *\t@param {Object} old\t\t\tCurrent/previous attributes (from previous VNode or element's prop cache)\n */\nfunction diffAttributes(dom, attrs, old) {\n\tvar name;\n\n\t// remove attributes no longer present on the vnode by setting them to undefined\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name] != null) && old[name] != null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\t// add new & update changed attributes\n\tfor (name in attrs) {\n\t\tif (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n\n/** Retains a pool of Components for re-use, keyed on component name.\n *\tNote: since component names are not unique or even necessarily available, these are primarily a form of sharding.\n *\t@private\n */\nvar components = {};\n\n/** Reclaim a component for later re-use by the recycler. */\nfunction collectComponent(component) {\n\tvar name = component.constructor.name;\n\t(components[name] || (components[name] = [])).push(component);\n}\n\n/** Create a component. Normalizes differences between PFC's and classful Components. */\nfunction createComponent(Ctor, props, context) {\n\tvar list = components[Ctor.name],\n\t    inst;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t} else {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\tif (list) {\n\t\tfor (var i = list.length; i--;) {\n\t\t\tif (list[i].constructor === Ctor) {\n\t\t\t\tinst.nextBase = list[i].nextBase;\n\t\t\t\tlist.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn inst;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n\n/** Set a component's `props` (generally derived from JSX attributes).\n *\t@param {Object} props\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.renderSync=false]\tIf `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.\n *\t@param {boolean} [opts.render=true]\t\t\tIf `false`, no render will be triggered.\n */\nfunction setComponentProps(component, props, opts, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tif (component.__ref = props.ref) delete props.ref;\n\tif (component.__key = props.key) delete props.key;\n\n\tif (!component.base || mountAll) {\n\t\tif (component.componentWillMount) component.componentWillMount();\n\t} else if (component.componentWillReceiveProps) {\n\t\tcomponent.componentWillReceiveProps(props, context);\n\t}\n\n\tif (context && context !== component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (opts !== 0) {\n\t\tif (opts === 1 || options.syncComponentUpdates !== false || !component.base) {\n\t\t\trenderComponent(component, 1, mountAll);\n\t\t} else {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tif (component.__ref) component.__ref(component);\n}\n\n/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.\n *\t@param {Component} component\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.build=false]\t\tIf `true`, component will build and store a DOM node if not already associated with one.\n *\t@private\n */\nfunction renderComponent(component, opts, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tvar props = component.props,\n\t    state = component.state,\n\t    context = component.context,\n\t    previousProps = component.prevProps || props,\n\t    previousState = component.prevState || state,\n\t    previousContext = component.prevContext || context,\n\t    isUpdate = component.base,\n\t    nextBase = component.nextBase,\n\t    initialBase = isUpdate || nextBase,\n\t    initialChildComponent = component._component,\n\t    skip = false,\n\t    rendered,\n\t    inst,\n\t    cbase;\n\n\t// if updating\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t} else if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\t// context to pass to the child, can be updated via (grand-)parent component\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend(extend({}, context), component.getChildContext());\n\t\t}\n\n\t\tvar childComponent = rendered && rendered.nodeName,\n\t\t    toUnmount,\n\t\t    base;\n\n\t\tif (typeof childComponent === 'function') {\n\t\t\t// set up high order component link\n\n\t\t\tvar childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor === childComponent && childProps.key == inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, 1, context, false);\n\t\t\t} else {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, 0, context, false);\n\t\t\t\trenderComponent(inst, 1, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t} else {\n\t\t\tcbase = initialBase;\n\n\t\t\t// destroy high order component link\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || opts === 1) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base !== initialBase && inst !== initialChildComponent) {\n\t\t\tvar baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base !== baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tvar componentRef = component,\n\t\t\t    t = component;\n\t\t\twhile (t = t._parentComponent) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.unshift(component);\n\t} else if (!skip) {\n\t\t// Ensure that pending componentDidMount() hooks of child components\n\t\t// are called before the componentDidUpdate() hook in the parent.\n\t\t// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750\n\t\t// flushMounts();\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, previousContext);\n\t\t}\n\t\tif (options.afterUpdate) options.afterUpdate(component);\n\t}\n\n\tif (component._renderCallbacks != null) {\n\t\twhile (component._renderCallbacks.length) {\n\t\t\tcomponent._renderCallbacks.pop().call(component);\n\t\t}\n\t}\n\n\tif (!diffLevel && !isChild) flushMounts();\n}\n\n/** Apply the Component referenced by a VNode to the DOM.\n *\t@param {Element} dom\tThe DOM node to mutate\n *\t@param {VNode} vnode\tA Component-referencing VNode\n *\t@returns {Element} dom\tThe created/mutated element\n *\t@private\n */\nfunction buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tvar c = dom && dom._component,\n\t    originalComponent = c,\n\t    oldDom = dom,\n\t    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,\n\t    isOwner = isDirectOwner,\n\t    props = getNodeProps(vnode);\n\twhile (c && !isOwner && (c = c._parentComponent)) {\n\t\tisOwner = c.constructor === vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, 3, context, mountAll);\n\t\tdom = c.base;\n\t} else {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\t\t\t// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, 1, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom !== oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/** Remove a component from the DOM and recycle it.\n *\t@param {Component} component\tThe Component instance to unmount\n *\t@private\n */\nfunction unmountComponent(component) {\n\tif (options.beforeUnmount) options.beforeUnmount(component);\n\n\tvar base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\t// recursively tear down & recollect high-order component children:\n\tvar inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t} else if (base) {\n\t\tif (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\tcollectComponent(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tif (component.__ref) component.__ref(null);\n}\n\n/** Base Component class.\n *\tProvides `setState()` and `forceUpdate()`, which trigger rendering.\n *\t@public\n *\n *\t@example\n *\tclass MyFoo extends Component {\n *\t\trender(props, state) {\n *\t\t\treturn <div />;\n *\t\t}\n *\t}\n */\nfunction Component(props, context) {\n\tthis._dirty = true;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.context = context;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.props = props;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.state = this.state || {};\n}\n\nextend(Component.prototype, {\n\n\t/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.\n  *\t@param {object} nextProps\n  *\t@param {object} nextState\n  *\t@param {object} nextContext\n  *\t@returns {Boolean} should the component re-render\n  *\t@name shouldComponentUpdate\n  *\t@function\n  */\n\n\t/** Update component state by copying properties from `state` to `this.state`.\n  *\t@param {object} state\t\tA hash of state properties to update with new values\n  *\t@param {function} callback\tA function to be called once component state is updated\n  */\n\tsetState: function setState(state, callback) {\n\t\tvar s = this.state;\n\t\tif (!this.prevState) this.prevState = extend({}, s);\n\t\textend(s, typeof state === 'function' ? state(s, this.props) : state);\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\tenqueueRender(this);\n\t},\n\n\n\t/** Immediately perform a synchronous re-render of the component.\n  *\t@param {function} callback\t\tA function to be called after component is re-rendered.\n  *\t@private\n  */\n\tforceUpdate: function forceUpdate(callback) {\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\trenderComponent(this, 2);\n\t},\n\n\n\t/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n  *\tVirtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n  *\t@param {object} props\t\tProps (eg: JSX attributes) received from parent element/component\n  *\t@param {object} state\t\tThe component's current state\n  *\t@param {object} context\t\tContext object (if a parent component has provided context)\n  *\t@returns VNode\n  */\n\trender: function render() {}\n});\n\n/** Render JSX into a `parent` Element.\n *\t@param {VNode} vnode\t\tA (JSX) VNode to render\n *\t@param {Element} parent\t\tDOM element to render into\n *\t@param {Element} [merge]\tAttempt to re-use an existing DOM tree rooted at `merge`\n *\t@public\n *\n *\t@example\n *\t// render a div into <body>:\n *\trender(<div id=\"hello\">hello!</div>, document.body);\n *\n *\t@example\n *\t// render a \"Thing\" component into #foo:\n *\tconst Thing = ({ name }) => <span>{ name }</span>;\n *\trender(<Thing name=\"one\" />, document.querySelector('#foo'));\n */\nfunction render(vnode, parent, merge) {\n  return diff(merge, vnode, {}, false, parent, false);\n}\n\nvar preact = {\n\th: h,\n\tcreateElement: h,\n\tcloneElement: cloneElement,\n\tComponent: Component,\n\trender: render,\n\trerender: rerender,\n\toptions: options\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (preact);\n//# sourceMappingURL=preact.esm.js.map\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact_render_to_string__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact_render_to_string___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_preact_render_to_string__);\n\r\n\r\n\r\nconst { h, Component } = __WEBPACK_IMPORTED_MODULE_0_preact__[\"a\" /* default */];\r\n\r\nconst H1 = ({ children }) => h('h1', null, children);\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return h('div', null, h(H1, null, 'Hello, world!'));\r\n  }\r\n}\r\n\r\nconsole.log(__WEBPACK_IMPORTED_MODULE_1_preact_render_to_string___default()(h(App)));\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 866aac55c2ec8414b6a5","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.preactRenderToString = factory());\n}(this, (function () {\n\nvar NON_DIMENSION_PROPS = {\n\tboxFlex: 1, boxFlexGroup: 1, columnCount: 1, fillOpacity: 1, flex: 1, flexGrow: 1,\n\tflexPositive: 1, flexShrink: 1, flexNegative: 1, fontWeight: 1, lineClamp: 1, lineHeight: 1,\n\topacity: 1, order: 1, orphans: 1, strokeOpacity: 1, widows: 1, zIndex: 1, zoom: 1\n};\n\nvar ESC = {\n\t'<': '&lt;',\n\t'>': '&gt;',\n\t'\"': '&quot;',\n\t'&': '&amp;'\n};\n\nvar objectKeys = Object.keys || function (obj) {\n\tvar keys = [];\n\tfor (var i in obj) {\n\t\tif (obj.hasOwnProperty(i)) keys.push(i);\n\t}return keys;\n};\n\nvar encodeEntities = function (s) {\n\treturn String(s).replace(/[<>\"&]/g, escapeChar);\n};\n\nvar escapeChar = function (a) {\n\treturn ESC[a] || a;\n};\n\nvar falsey = function (v) {\n\treturn v == null || v === false;\n};\n\nvar memoize = function (fn) {\n\tvar mem = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\treturn function (v) {\n\t\treturn mem[v] || (mem[v] = fn(v));\n\t};\n};\n\nvar indent = function (s, char) {\n\treturn String(s).replace(/(\\n+)/g, '$1' + (char || '\\t'));\n};\n\nvar isLargeString = function (s, length, ignoreLines) {\n\treturn String(s).length > (length || 40) || !ignoreLines && String(s).indexOf('\\n') !== -1 || String(s).indexOf('<') !== -1;\n};\n\nfunction styleObjToCss(s) {\n\tvar str = '';\n\tfor (var prop in s) {\n\t\tvar val = s[prop];\n\t\tif (val != null) {\n\t\t\tif (str) str += ' ';\n\t\t\tstr += jsToCss(prop);\n\t\t\tstr += ': ';\n\t\t\tstr += val;\n\t\t\tif (typeof val === 'number' && !NON_DIMENSION_PROPS[prop]) {\n\t\t\t\tstr += 'px';\n\t\t\t}\n\t\t\tstr += ';';\n\t\t}\n\t}\n\treturn str || undefined;\n}\n\nfunction hashToClassName(c) {\n\tvar str = '';\n\tfor (var prop in c) {\n\t\tif (c[prop]) {\n\t\t\tif (str) str += ' ';\n\t\t\tstr += prop;\n\t\t}\n\t}\n\treturn str;\n}\n\nvar jsToCss = memoize(function (s) {\n\treturn s.replace(/([A-Z])/g, '-$1').toLowerCase();\n});\n\nfunction assign(obj, props) {\n\tfor (var i in props) {\n\t\tobj[i] = props[i];\n\t}return obj;\n}\n\nfunction getNodeProps(vnode) {\n\tvar defaultProps = vnode.nodeName.defaultProps,\n\t    props = assign({}, defaultProps || vnode.attributes);\n\tif (defaultProps) assign(props, vnode.attributes);\n\tif (vnode.children) props.children = vnode.children;\n\treturn props;\n}\n\nvar SHALLOW = { shallow: true };\n\nvar UNNAMED = [];\n\nvar EMPTY = {};\n\nvar VOID_ELEMENTS = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\nrenderToString.render = renderToString;\n\nvar shallowRender = function (vnode, context) {\n\treturn renderToString(vnode, context, SHALLOW);\n};\n\nfunction renderToString(vnode, context, opts, inner, isSvgMode) {\n\tvar _ref = vnode || EMPTY;\n\n\tvar nodeName = _ref.nodeName;\n\tvar attributes = _ref.attributes;\n\tvar children = _ref.children;\n\tvar isComponent = false;\n\tcontext = context || {};\n\topts = opts || {};\n\n\tvar pretty = opts.pretty,\n\t    indentChar = typeof pretty === 'string' ? pretty : '\\t';\n\n\tif (vnode == null || vnode === false) {\n\t\treturn '';\n\t}\n\n\tif (!nodeName) {\n\t\treturn encodeEntities(vnode);\n\t}\n\n\tif (typeof nodeName === 'function') {\n\t\tisComponent = true;\n\t\tif (opts.shallow && (inner || opts.renderRootComponent === false)) {\n\t\t\tnodeName = getComponentName(nodeName);\n\t\t} else {\n\t\t\tvar props = getNodeProps(vnode),\n\t\t\t    rendered = void 0;\n\n\t\t\tif (!nodeName.prototype || typeof nodeName.prototype.render !== 'function') {\n\t\t\t\trendered = nodeName(props, context);\n\t\t\t} else {\n\t\t\t\tvar c = new nodeName(props, context);\n\n\t\t\t\tc._disable = c.__x = true;\n\t\t\t\tc.props = props;\n\t\t\t\tc.context = context;\n\t\t\t\tif (c.componentWillMount) c.componentWillMount();\n\t\t\t\trendered = c.render(c.props, c.state, c.context);\n\n\t\t\t\tif (c.getChildContext) {\n\t\t\t\t\tcontext = assign(assign({}, context), c.getChildContext());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn renderToString(rendered, context, opts, opts.shallowHighOrder !== false);\n\t\t}\n\t}\n\n\tvar s = '',\n\t    html = void 0;\n\n\tif (attributes) {\n\t\tvar attrs = objectKeys(attributes);\n\n\t\tif (opts && opts.sortAttributes === true) attrs.sort();\n\n\t\tfor (var i = 0; i < attrs.length; i++) {\n\t\t\tvar name = attrs[i],\n\t\t\t    v = attributes[name];\n\t\t\tif (name === 'children') continue;\n\t\t\tif (!(opts && opts.allAttributes) && (name === 'key' || name === 'ref')) continue;\n\n\t\t\tif (name === 'className') {\n\t\t\t\tif (attributes['class']) continue;\n\t\t\t\tname = 'class';\n\t\t\t} else if (isSvgMode && name.match(/^xlink\\:?(.+)/)) {\n\t\t\t\tname = name.toLowerCase().replace(/^xlink\\:?(.+)/, 'xlink:$1');\n\t\t\t}\n\n\t\t\tif (name === 'class' && v && typeof v === 'object') {\n\t\t\t\tv = hashToClassName(v);\n\t\t\t} else if (name === 'style' && v && typeof v === 'object') {\n\t\t\t\tv = styleObjToCss(v);\n\t\t\t}\n\n\t\t\tvar hooked = opts.attributeHook && opts.attributeHook(name, v, context, opts, isComponent);\n\t\t\tif (hooked || hooked === '') {\n\t\t\t\ts += hooked;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (name === 'dangerouslySetInnerHTML') {\n\t\t\t\thtml = v && v.__html;\n\t\t\t} else if ((v || v === 0 || v === '') && typeof v !== 'function') {\n\t\t\t\tif (v === true || v === '') {\n\t\t\t\t\tv = name;\n\n\t\t\t\t\tif (!opts || !opts.xml) {\n\t\t\t\t\t\ts += ' ' + name;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts += ' ' + name + '=\"' + encodeEntities(v) + '\"';\n\t\t\t}\n\t\t}\n\t}\n\n\tvar sub = s.replace(/^\\n\\s*/, ' ');\n\tif (sub !== s && !~sub.indexOf('\\n')) s = sub;else if (pretty && ~s.indexOf('\\n')) s += '\\n';\n\n\ts = '<' + nodeName + s + '>';\n\n\tif (VOID_ELEMENTS.indexOf(nodeName) > -1) {\n\t\ts = s.replace(/>$/, ' />');\n\t}\n\n\tif (html) {\n\t\tif (pretty && isLargeString(html)) {\n\t\t\thtml = '\\n' + indentChar + indent(html, indentChar);\n\t\t}\n\t\ts += html;\n\t} else {\n\t\tvar len = children && children.length,\n\t\t    pieces = [],\n\t\t    hasLarge = ~s.indexOf('\\n');\n\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\tvar child = children[_i];\n\t\t\tif (!falsey(child)) {\n\t\t\t\tvar childSvgMode = nodeName === 'svg' ? true : nodeName === 'foreignObject' ? false : isSvgMode,\n\t\t\t\t    ret = renderToString(child, context, opts, true, childSvgMode);\n\t\t\t\tif (!hasLarge && pretty && isLargeString(ret)) hasLarge = true;\n\t\t\t\tif (ret) pieces.push(ret);\n\t\t\t}\n\t\t}\n\t\tif (pretty && hasLarge) {\n\t\t\tfor (var _i2 = pieces.length; _i2--;) {\n\t\t\t\tpieces[_i2] = '\\n' + indentChar + indent(pieces[_i2], indentChar);\n\t\t\t}\n\t\t}\n\t\tif (pieces.length) {\n\t\t\ts += pieces.join('');\n\t\t} else if (opts && opts.xml) {\n\t\t\treturn s.substring(0, s.length - 1) + ' />';\n\t\t}\n\t}\n\n\tif (opts.jsx || VOID_ELEMENTS.indexOf(nodeName) === -1) {\n\t\tif (pretty && ~s.indexOf('\\n')) s += '\\n';\n\t\ts += '</' + nodeName + '>';\n\t}\n\n\treturn s;\n}\n\nfunction getComponentName(component) {\n\tvar proto = component.prototype,\n\t    ctor = proto && proto.constructor;\n\treturn component.displayName || component.name || proto && (proto.displayName || proto.name) || getFallbackComponentName(component);\n}\n\nfunction getFallbackComponentName(component) {\n\tvar str = Function.prototype.toString.call(component),\n\t    name = (str.match(/^\\s*function\\s+([^\\( ]+)/) || EMPTY)[1];\n\tif (!name) {\n\t\tvar index = -1;\n\t\tfor (var i = UNNAMED.length; i--;) {\n\t\t\tif (UNNAMED[i] === component) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (index < 0) {\n\t\t\tindex = UNNAMED.push(component) - 1;\n\t\t}\n\t\tname = 'UnnamedComponent' + index;\n\t}\n\treturn name;\n}\nrenderToString.shallowRender = shallowRender;\n\nreturn renderToString;\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/preact-render-to-string/dist/index.js\n// module id = 0\n// module chunks = 0","/** Virtual DOM Node */\nfunction VNode() {}\n\n/** Global options\n *\t@public\n *\t@namespace options {Object}\n */\nvar options = {\n\n\t/** If `true`, `prop` changes trigger synchronous component updates.\n  *\t@name syncComponentUpdates\n  *\t@type Boolean\n  *\t@default true\n  */\n\t//syncComponentUpdates: true,\n\n\t/** Processes all created VNodes.\n  *\t@param {VNode} vnode\tA newly-created VNode to normalize/process\n  */\n\t//vnode(vnode) { }\n\n\t/** Hook invoked after a component is mounted. */\n\t// afterMount(component) { }\n\n\t/** Hook invoked after the DOM is updated with a component's latest render. */\n\t// afterUpdate(component) { }\n\n\t/** Hook invoked immediately before a component is unmounted. */\n\t// beforeUnmount(component) { }\n};\n\nvar stack = [];\n\nvar EMPTY_CHILDREN = [];\n\n/** JSX/hyperscript reviver\n*\tBenchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0\n *\t@see http://jasonformat.com/wtf-is-jsx\n *\t@public\n */\nfunction h(nodeName, attributes) {\n\tvar children = EMPTY_CHILDREN,\n\t    lastSimple,\n\t    child,\n\t    simple,\n\t    i;\n\tfor (i = arguments.length; i-- > 2;) {\n\t\tstack.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children != null) {\n\t\tif (!stack.length) stack.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack.length) {\n\t\tif ((child = stack.pop()) && child.pop !== undefined) {\n\t\t\tfor (i = child.length; i--;) {\n\t\t\t\tstack.push(child[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof child === 'boolean') child = null;\n\n\t\t\tif (simple = typeof nodeName !== 'function') {\n\t\t\t\tif (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length - 1] += child;\n\t\t\t} else if (children === EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t} else {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tvar p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes == null ? undefined : attributes;\n\tp.key = attributes == null ? undefined : attributes.key;\n\n\t// if a \"vnode hook\" is defined, pass every created VNode to it\n\tif (options.vnode !== undefined) options.vnode(p);\n\n\treturn p;\n}\n\n/** Copy own-properties from `props` onto `obj`.\n *\t@returns obj\n *\t@private\n */\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }return obj;\n}\n\n/** Call a function asynchronously, as soon as possible.\n *\t@param {Function} callback\n */\nvar defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n\nfunction cloneElement(vnode, props) {\n\treturn h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n}\n\n// DOM properties that should NOT have \"px\" added when numeric\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\n/** Managed queue of dirty components to be re-rendered */\n\nvar items = [];\n\nfunction enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component) == 1) {\n\t\t(options.debounceRendering || defer)(rerender);\n\t}\n}\n\nfunction rerender() {\n\tvar p,\n\t    list = items;\n\titems = [];\n\twhile (p = list.pop()) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n\n/** Check if two nodes are equivalent.\n *\t@param {Element} node\n *\t@param {VNode} vnode\n *\t@private\n */\nfunction isSameNodeType(node, vnode, hydrating) {\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\treturn node.splitText !== undefined;\n\t}\n\tif (typeof vnode.nodeName === 'string') {\n\t\treturn !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n\t}\n\treturn hydrating || node._componentConstructor === vnode.nodeName;\n}\n\n/** Check if an Element has a given normalized name.\n*\t@param {Element} node\n*\t@param {String} nodeName\n */\nfunction isNamedNode(node, nodeName) {\n\treturn node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n}\n\n/**\n * Reconstruct Component-style `props` from a VNode.\n * Ensures default/fallback values from `defaultProps`:\n * Own-properties of `defaultProps` not present in `vnode.attributes` are added.\n * @param {VNode} vnode\n * @returns {Object} props\n */\nfunction getNodeProps(vnode) {\n\tvar props = extend({}, vnode.attributes);\n\tprops.children = vnode.children;\n\n\tvar defaultProps = vnode.nodeName.defaultProps;\n\tif (defaultProps !== undefined) {\n\t\tfor (var i in defaultProps) {\n\t\t\tif (props[i] === undefined) {\n\t\t\t\tprops[i] = defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn props;\n}\n\n/** Create an element with the given nodeName.\n *\t@param {String} nodeName\n *\t@param {Boolean} [isSvg=false]\tIf `true`, creates an element within the SVG namespace.\n *\t@returns {Element} node\n */\nfunction createNode(nodeName, isSvg) {\n\tvar node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\n/** Remove a child node from its parent if attached.\n *\t@param {Element} node\t\tThe node to remove\n */\nfunction removeNode(node) {\n\tvar parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\n/** Set a named attribute on the given Node, with special behavior for some names and event handlers.\n *\tIf `value` is `null`, the attribute/handler will be removed.\n *\t@param {Element} node\tAn element to mutate\n *\t@param {string} name\tThe name/key to set, such as an event or attribute name\n *\t@param {any} old\tThe last value that was set for this name/node pair\n *\t@param {any} value\tAn attribute value, such as a function to be used as an event handler\n *\t@param {Boolean} isSvg\tAre we currently diffing inside an svg?\n *\t@private\n */\nfunction setAccessor(node, name, old, value, isSvg) {\n\tif (name === 'className') name = 'class';\n\n\tif (name === 'key') {\n\t\t// ignore\n\t} else if (name === 'ref') {\n\t\tif (old) old(null);\n\t\tif (value) value(node);\n\t} else if (name === 'class' && !isSvg) {\n\t\tnode.className = value || '';\n\t} else if (name === 'style') {\n\t\tif (!value || typeof value === 'string' || typeof old === 'string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value === 'object') {\n\t\t\tif (typeof old !== 'string') {\n\t\t\t\tfor (var i in old) {\n\t\t\t\t\tif (!(i in value)) node.style[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in value) {\n\t\t\t\tnode.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];\n\t\t\t}\n\t\t}\n\t} else if (name === 'dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t} else if (name[0] == 'o' && name[1] == 'n') {\n\t\tvar useCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {\n\t\tsetProperty(node, name, value == null ? '' : value);\n\t\tif (value == null || value === false) node.removeAttribute(name);\n\t} else {\n\t\tvar ns = isSvg && name !== (name = name.replace(/^xlink\\:?/, ''));\n\t\tif (value == null || value === false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/** Attempt to set a DOM property to the given value.\n *\tIE & FF throw for certain property-value combinations.\n */\nfunction setProperty(node, name, value) {\n\ttry {\n\t\tnode[name] = value;\n\t} catch (e) {}\n}\n\n/** Proxy an event to hooked event handlers\n *\t@private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event && options.event(e) || e);\n}\n\n/** Queue of components that have been mounted and are awaiting componentDidMount */\nvar mounts = [];\n\n/** Diff recursion count, used to track the end of the diff cycle. */\nvar diffLevel = 0;\n\n/** Global flag indicating if the diff is currently within an SVG */\nvar isSvgMode = false;\n\n/** Global flag indicating if the diff is performing hydration */\nvar hydrating = false;\n\n/** Invoke queued componentDidMount lifecycle methods */\nfunction flushMounts() {\n\tvar c;\n\twhile (c = mounts.pop()) {\n\t\tif (options.afterMount) options.afterMount(c);\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\n/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.\n *\t@param {Element} [dom=null]\t\tA DOM node to mutate into the shape of the `vnode`\n *\t@param {VNode} vnode\t\t\tA VNode (with descendants forming a tree) representing the desired DOM structure\n *\t@returns {Element} dom\t\t\tThe created/mutated element\n *\t@private\n */\nfunction diff(dom, vnode, context, mountAll, parent, componentRoot) {\n\t// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)\n\tif (!diffLevel++) {\n\t\t// when first starting the diff, check if we're diffing an SVG or within an SVG\n\t\tisSvgMode = parent != null && parent.ownerSVGElement !== undefined;\n\n\t\t// hydration is indicated by the existing element to be diffed not having a prop cache\n\t\thydrating = dom != null && !('__preactattr_' in dom);\n\t}\n\n\tvar ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\t// append the element if its a new parent\n\tif (parent && ret.parentNode !== parent) parent.appendChild(ret);\n\n\t// diffLevel being reduced to 0 means we're exiting the diff\n\tif (! --diffLevel) {\n\t\thydrating = false;\n\t\t// invoke queued componentDidMount lifecycle methods\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\n/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tvar out = dom,\n\t    prevSvgMode = isSvgMode;\n\n\t// empty values (null, undefined, booleans) render as empty Text nodes\n\tif (vnode == null || typeof vnode === 'boolean') vnode = '';\n\n\t// Fast case: Strings & Numbers create/update Text nodes.\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\n\t\t// update if it's already a Text node:\n\t\tif (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\t/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */\n\t\t\tif (dom.nodeValue != vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t} else {\n\t\t\t// it wasn't a Text node: replace it with one and recycle the old Element\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout['__preactattr_'] = true;\n\n\t\treturn out;\n\t}\n\n\t// If the VNode represents a Component, perform a component diff:\n\tvar vnodeName = vnode.nodeName;\n\tif (typeof vnodeName === 'function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;\n\n\t// If there's no existing element or it's the wrong type, create a new one:\n\tvnodeName = String(vnodeName);\n\tif (!dom || !isNamedNode(dom, vnodeName)) {\n\t\tout = createNode(vnodeName, isSvgMode);\n\n\t\tif (dom) {\n\t\t\t// move children into the replacement node\n\t\t\twhile (dom.firstChild) {\n\t\t\t\tout.appendChild(dom.firstChild);\n\t\t\t} // if the previous Element was mounted into the DOM, replace it inline\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\t// recycle the old element (skips non-Element node types)\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\tvar fc = out.firstChild,\n\t    props = out['__preactattr_'],\n\t    vchildren = vnode.children;\n\n\tif (props == null) {\n\t\tprops = out['__preactattr_'] = {};\n\t\tfor (var a = out.attributes, i = a.length; i--;) {\n\t\t\tprops[a[i].name] = a[i].value;\n\t\t}\n\t}\n\n\t// Optimization: fast-path for elements containing a single TextNode:\n\tif (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {\n\t\tif (fc.nodeValue != vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t}\n\t// otherwise, if there are existing or new children, diff them:\n\telse if (vchildren && vchildren.length || fc != null) {\n\t\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);\n\t\t}\n\n\t// Apply attributes/props from VNode to the DOM Element:\n\tdiffAttributes(out, vnode.attributes, props);\n\n\t// restore previous SVG mode: (in case we're exiting an SVG namespace)\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\n/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.\n *\t@param {Element} dom\t\t\tElement whose children should be compared & mutated\n *\t@param {Array} vchildren\t\tArray of VNodes to compare to `dom.childNodes`\n *\t@param {Object} context\t\t\tImplicitly descendant context object (from most recent `getChildContext()`)\n *\t@param {Boolean} mountAll\n *\t@param {Boolean} isHydrating\tIf `true`, consumes externally created elements similar to hydration\n */\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tvar originalChildren = dom.childNodes,\n\t    children = [],\n\t    keyed = {},\n\t    keyedLen = 0,\n\t    min = 0,\n\t    len = originalChildren.length,\n\t    childrenLen = 0,\n\t    vlen = vchildren ? vchildren.length : 0,\n\t    j,\n\t    c,\n\t    f,\n\t    vchild,\n\t    child;\n\n\t// Build up a map of keyed children and an Array of unkeyed children:\n\tif (len !== 0) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar _child = originalChildren[i],\n\t\t\t    props = _child['__preactattr_'],\n\t\t\t    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;\n\t\t\tif (key != null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = _child;\n\t\t\t} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = _child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen !== 0) {\n\t\tfor (var i = 0; i < vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\t// attempt to find a node based on key matching\n\t\t\tvar key = vchild.key;\n\t\t\tif (key != null) {\n\t\t\t\tif (keyedLen && keyed[key] !== undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// attempt to pluck a node of the same type from the existing children\n\t\t\telse if (!child && min < childrenLen) {\n\t\t\t\t\tfor (j = min; j < childrenLen; j++) {\n\t\t\t\t\t\tif (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\t\tif (j === childrenLen - 1) childrenLen--;\n\t\t\t\t\t\t\tif (j === min) min++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// morph the matched/found/created DOM child to match vchild (deep)\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tf = originalChildren[i];\n\t\t\tif (child && child !== dom && child !== f) {\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t} else if (child === f.nextSibling) {\n\t\t\t\t\tremoveNode(f);\n\t\t\t\t} else {\n\t\t\t\t\tdom.insertBefore(child, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// remove unused keyed children:\n\tif (keyedLen) {\n\t\tfor (var i in keyed) {\n\t\t\tif (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);\n\t\t}\n\t}\n\n\t// remove orphaned unkeyed children:\n\twhile (min <= childrenLen) {\n\t\tif ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);\n\t}\n}\n\n/** Recursively recycle (or just unmount) a node and its descendants.\n *\t@param {Node} node\t\t\t\t\t\tDOM node to start unmount/removal from\n *\t@param {Boolean} [unmountOnly=false]\tIf `true`, only triggers unmount lifecycle, skips removal\n */\nfunction recollectNodeTree(node, unmountOnly) {\n\tvar component = node._component;\n\tif (component) {\n\t\t// if node is owned by a Component, unmount that component (ends up recursing back here)\n\t\tunmountComponent(component);\n\t} else {\n\t\t// If the node's VNode had a ref function, invoke it with null here.\n\t\t// (this is part of the React spec, and smart for unsetting references)\n\t\tif (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);\n\n\t\tif (unmountOnly === false || node['__preactattr_'] == null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\n/** Recollect/unmount all children.\n *\t- we use .lastChild here because it causes less reflow than .firstChild\n *\t- it's also cheaper than accessing the .childNodes Live NodeList\n */\nfunction removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tvar next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\n/** Apply differences in attributes from a VNode to the given DOM Element.\n *\t@param {Element} dom\t\tElement with attributes to diff `attrs` against\n *\t@param {Object} attrs\t\tThe desired end-state key-value attribute pairs\n *\t@param {Object} old\t\t\tCurrent/previous attributes (from previous VNode or element's prop cache)\n */\nfunction diffAttributes(dom, attrs, old) {\n\tvar name;\n\n\t// remove attributes no longer present on the vnode by setting them to undefined\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name] != null) && old[name] != null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\t// add new & update changed attributes\n\tfor (name in attrs) {\n\t\tif (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n\n/** Retains a pool of Components for re-use, keyed on component name.\n *\tNote: since component names are not unique or even necessarily available, these are primarily a form of sharding.\n *\t@private\n */\nvar components = {};\n\n/** Reclaim a component for later re-use by the recycler. */\nfunction collectComponent(component) {\n\tvar name = component.constructor.name;\n\t(components[name] || (components[name] = [])).push(component);\n}\n\n/** Create a component. Normalizes differences between PFC's and classful Components. */\nfunction createComponent(Ctor, props, context) {\n\tvar list = components[Ctor.name],\n\t    inst;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t} else {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\tif (list) {\n\t\tfor (var i = list.length; i--;) {\n\t\t\tif (list[i].constructor === Ctor) {\n\t\t\t\tinst.nextBase = list[i].nextBase;\n\t\t\t\tlist.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn inst;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n\n/** Set a component's `props` (generally derived from JSX attributes).\n *\t@param {Object} props\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.renderSync=false]\tIf `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.\n *\t@param {boolean} [opts.render=true]\t\t\tIf `false`, no render will be triggered.\n */\nfunction setComponentProps(component, props, opts, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tif (component.__ref = props.ref) delete props.ref;\n\tif (component.__key = props.key) delete props.key;\n\n\tif (!component.base || mountAll) {\n\t\tif (component.componentWillMount) component.componentWillMount();\n\t} else if (component.componentWillReceiveProps) {\n\t\tcomponent.componentWillReceiveProps(props, context);\n\t}\n\n\tif (context && context !== component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (opts !== 0) {\n\t\tif (opts === 1 || options.syncComponentUpdates !== false || !component.base) {\n\t\t\trenderComponent(component, 1, mountAll);\n\t\t} else {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tif (component.__ref) component.__ref(component);\n}\n\n/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.\n *\t@param {Component} component\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.build=false]\t\tIf `true`, component will build and store a DOM node if not already associated with one.\n *\t@private\n */\nfunction renderComponent(component, opts, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tvar props = component.props,\n\t    state = component.state,\n\t    context = component.context,\n\t    previousProps = component.prevProps || props,\n\t    previousState = component.prevState || state,\n\t    previousContext = component.prevContext || context,\n\t    isUpdate = component.base,\n\t    nextBase = component.nextBase,\n\t    initialBase = isUpdate || nextBase,\n\t    initialChildComponent = component._component,\n\t    skip = false,\n\t    rendered,\n\t    inst,\n\t    cbase;\n\n\t// if updating\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t} else if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\t// context to pass to the child, can be updated via (grand-)parent component\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend(extend({}, context), component.getChildContext());\n\t\t}\n\n\t\tvar childComponent = rendered && rendered.nodeName,\n\t\t    toUnmount,\n\t\t    base;\n\n\t\tif (typeof childComponent === 'function') {\n\t\t\t// set up high order component link\n\n\t\t\tvar childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor === childComponent && childProps.key == inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, 1, context, false);\n\t\t\t} else {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, 0, context, false);\n\t\t\t\trenderComponent(inst, 1, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t} else {\n\t\t\tcbase = initialBase;\n\n\t\t\t// destroy high order component link\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || opts === 1) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base !== initialBase && inst !== initialChildComponent) {\n\t\t\tvar baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base !== baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tvar componentRef = component,\n\t\t\t    t = component;\n\t\t\twhile (t = t._parentComponent) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.unshift(component);\n\t} else if (!skip) {\n\t\t// Ensure that pending componentDidMount() hooks of child components\n\t\t// are called before the componentDidUpdate() hook in the parent.\n\t\t// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750\n\t\t// flushMounts();\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, previousContext);\n\t\t}\n\t\tif (options.afterUpdate) options.afterUpdate(component);\n\t}\n\n\tif (component._renderCallbacks != null) {\n\t\twhile (component._renderCallbacks.length) {\n\t\t\tcomponent._renderCallbacks.pop().call(component);\n\t\t}\n\t}\n\n\tif (!diffLevel && !isChild) flushMounts();\n}\n\n/** Apply the Component referenced by a VNode to the DOM.\n *\t@param {Element} dom\tThe DOM node to mutate\n *\t@param {VNode} vnode\tA Component-referencing VNode\n *\t@returns {Element} dom\tThe created/mutated element\n *\t@private\n */\nfunction buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tvar c = dom && dom._component,\n\t    originalComponent = c,\n\t    oldDom = dom,\n\t    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,\n\t    isOwner = isDirectOwner,\n\t    props = getNodeProps(vnode);\n\twhile (c && !isOwner && (c = c._parentComponent)) {\n\t\tisOwner = c.constructor === vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, 3, context, mountAll);\n\t\tdom = c.base;\n\t} else {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\t\t\t// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, 1, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom !== oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/** Remove a component from the DOM and recycle it.\n *\t@param {Component} component\tThe Component instance to unmount\n *\t@private\n */\nfunction unmountComponent(component) {\n\tif (options.beforeUnmount) options.beforeUnmount(component);\n\n\tvar base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\t// recursively tear down & recollect high-order component children:\n\tvar inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t} else if (base) {\n\t\tif (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\tcollectComponent(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tif (component.__ref) component.__ref(null);\n}\n\n/** Base Component class.\n *\tProvides `setState()` and `forceUpdate()`, which trigger rendering.\n *\t@public\n *\n *\t@example\n *\tclass MyFoo extends Component {\n *\t\trender(props, state) {\n *\t\t\treturn <div />;\n *\t\t}\n *\t}\n */\nfunction Component(props, context) {\n\tthis._dirty = true;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.context = context;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.props = props;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.state = this.state || {};\n}\n\nextend(Component.prototype, {\n\n\t/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.\n  *\t@param {object} nextProps\n  *\t@param {object} nextState\n  *\t@param {object} nextContext\n  *\t@returns {Boolean} should the component re-render\n  *\t@name shouldComponentUpdate\n  *\t@function\n  */\n\n\t/** Update component state by copying properties from `state` to `this.state`.\n  *\t@param {object} state\t\tA hash of state properties to update with new values\n  *\t@param {function} callback\tA function to be called once component state is updated\n  */\n\tsetState: function setState(state, callback) {\n\t\tvar s = this.state;\n\t\tif (!this.prevState) this.prevState = extend({}, s);\n\t\textend(s, typeof state === 'function' ? state(s, this.props) : state);\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\tenqueueRender(this);\n\t},\n\n\n\t/** Immediately perform a synchronous re-render of the component.\n  *\t@param {function} callback\t\tA function to be called after component is re-rendered.\n  *\t@private\n  */\n\tforceUpdate: function forceUpdate(callback) {\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\trenderComponent(this, 2);\n\t},\n\n\n\t/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n  *\tVirtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n  *\t@param {object} props\t\tProps (eg: JSX attributes) received from parent element/component\n  *\t@param {object} state\t\tThe component's current state\n  *\t@param {object} context\t\tContext object (if a parent component has provided context)\n  *\t@returns VNode\n  */\n\trender: function render() {}\n});\n\n/** Render JSX into a `parent` Element.\n *\t@param {VNode} vnode\t\tA (JSX) VNode to render\n *\t@param {Element} parent\t\tDOM element to render into\n *\t@param {Element} [merge]\tAttempt to re-use an existing DOM tree rooted at `merge`\n *\t@public\n *\n *\t@example\n *\t// render a div into <body>:\n *\trender(<div id=\"hello\">hello!</div>, document.body);\n *\n *\t@example\n *\t// render a \"Thing\" component into #foo:\n *\tconst Thing = ({ name }) => <span>{ name }</span>;\n *\trender(<Thing name=\"one\" />, document.querySelector('#foo'));\n */\nfunction render(vnode, parent, merge) {\n  return diff(merge, vnode, {}, false, parent, false);\n}\n\nvar preact = {\n\th: h,\n\tcreateElement: h,\n\tcloneElement: cloneElement,\n\tComponent: Component,\n\trender: render,\n\trerender: rerender,\n\toptions: options\n};\n\nexport { h, h as createElement, cloneElement, Component, render, rerender, options };export default preact;\n//# sourceMappingURL=preact.esm.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/preact/dist/preact.esm.js\n// module id = 1\n// module chunks = 0","import preact from 'preact';\r\nimport render from 'preact-render-to-string';\r\n\r\nconst { h, Component } = preact;\r\n\r\nconst H1 = ({ children }) => h('h1', null, children);\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return h('div', null, h(H1, null, 'Hello, world!'));\r\n  }\r\n}\r\n\r\nconsole.log(render(h(App)));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./test/entry.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}